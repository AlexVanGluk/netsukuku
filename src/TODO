		[HIGH PRIORITY] 

- Implement all the NTK_RFC: http://lab.dyne.org/Netsukuku_RFC

- Gnodes contiguity
	- Nodes count in the qspn_pkt which traverses gnodes	  [  50% ]
	- gnode re-hook
		- test: two nodes with the same IP
		- rehook() function				  [  55% ]
			- new gid based on the hash of the same gid, when
			  all the other gnodes are full.	  [  55% ]
			- ignore the rnodes of the previos gnode. [ 100% ]
			- at least one qspn_round must be passed. [ 100% ]
			- call rehook() from tracer_store()	  [ 100% ]
		- timed re-hook: the node waits that its rnodes, which are
		  nearer to the other gnode, do the re-hook first.[ 100% ]
		- merging of ext_maps				  [  65% ]
	
	- Challenge
		- RSA between rnodes: the nodes which are already hooked ask
		  for the public key to the node which is hooking.
		- Creation of the problem.
		- Resolution of the problem.
		- Diffusion of the reply.
		- Reject of challenge for X time after a first challenge has
		  been completed.
		- Do just one challenge at the same time, reject/delay all the
		  other which came later.
		- If the challenge was rejected/delayed wait the right amount
		  of time and retry.
		- Ban of gnodes which lost the challenge ?
		- Challenge between two gnode not contiguous, which have the
		  same gid.

- DNS wrapper: ip -> hostnames
	- -r forward to other /etc/resolv.conf dns server

		[MEDIUM PRIORITY] 

- The DNS wrapper, if launched in restricted mode, should forward the query to
  the other nameservers in /etc/resolv.conf if ANDNA told him that the
  hostname is inexistent.

- If the daemon is launched in restricted mode and with the -I it should find
  the nodes connected to Internet and add a default gw to them. Please refer
  to the NTK_RFC 0003.

- Bandwidth weight for each entry of the qspn (not just rtt and latency):
	- what to use to get the bandwidth of a network interface?

- Port the kernel route code for *BSD: take a look at rt_ioctl.c and
  rt_socket.c of quagga.
  
- API for the maps sync with the netsukuku_d daemon.

- Write the documentation for the code that can be used by other
  programs. (By the way it is already commented.)

- Interactive shell

		[LOW PRIORITY]

- Change with something else the eliminable fatal() calls in netsukuku_hook()

- Ipv6 support by the DNS wrapper.

- Test request.c

- Optimize random_ip() to return valid IPs. A possible solution would be
	to zero all the invalid bits.
