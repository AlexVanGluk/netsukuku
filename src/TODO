		[HIGH PRIORITY] 
		
- tracer_store_pkt: do not consider all the entries which are before our same
  entry, which we added in the pkt. This happens when there is a qspn_pkt
  which goes trough a circular loop.

- DNS wrapper: ip -> hostnames
	- -r forward to other /etc/resolv.conf dns server

- Bug:
  # pkt_q_wait_recv: Locking 0x80f6b9c!
  # Received ANDNA_GET_SINGLE_ACACHE from 175.97.103.220, id 0x2a347770
  *** glibc detected *** double free or corruption (!prev):***
  # Receiving reply for the ANDNA_REGISTER_HNAME request (id 0x7143c88a)

- Gnodes contiguity
	- Nodes count in the qspn_pkt which traverses gnodes
	- gnode re-hook
		- re-hook of two gnodes with different gid
		- re-hook of two gnodes with the  same gid
	
	- Challenge
		- RSA between rnodes: the nodes which are already hooked ask
		  for the public key to the node which is hooking.
		- Creation of the problem.
		- Resolution of the problem.
		- Diffusion of the reply.
		- Reject of challenge for X time after a first challenge has
		  been completed.
		- Do just one challenge at the same time, reject/delay all the
		  other which came later.
		- If the challenge was rejected/delayed wait the right amount
		  of time and retry.
		- Ban of gnodes which lost the challenge


		[MEDIUM PRIORITY] 

- Bandwidth weight for each entry of the qspn (not just rtt and latency):
	- what to use to get the bandwidth of a network interface?

- Port the kernel route code for *BSD: take a look at rt_ioctl.c and
  rt_socket.c of quagga.
  
- API for the maps sync with the netsukuku_d daemon.

- Write the documentation for the code that can be used by other
  programs. (By the way it is already commented.)

		[LOW PRIORITY]
		
- Ipv6 support by the DNS wrapper.

- Test request.c

- Optimize random_ip() to return valid IPs. A possible solution would be
	to zero all the invalid bits.
	
- Flush all the routes present in the routing table before starting the hook?
