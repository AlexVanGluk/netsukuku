*
**
***		HIGH PRIORITY
**
*	

* (generally these TODOs are already being implemented at the moment)


- SNSD
	- andna_cache.c:
		- acq_add()
	- andna_cache
		- pack
		- unpack
		- timestamp decoerence when saving on file?
	- lcl_cache
		- pack
		- unpack
	- rh_cache
		- pack
		- unpack
	- andna.pod (man page)
	- andna_register_hname()
		- do not contact the counter_node if we are just registering
		  a SNSD IP.
	- andna_resolve_hname()
		- can a client specify the queue number?
	- andna_rev_resolve()
	- snsd_load_files()

- Implement all the NTK_RFC: http://lab.dyne.org/Netsukuku_RFC

- update the dependencies list: 
	- depends on iptables
	- lartc
	
- restore the network when NetsukukuD is closed (call /etc/rc.d/rc.inet1 ?)

- Flash NetsukukuD into an AP and test it.


*
**
***		MEDIUM PRIORITY
**
*	


- Equalize multipath routes. The `equalize' module is still experimental in
  the kernel.

- bandwidth measurement
	- do not delete an inet-gw if there still bw passing on it.

- Bandwidth weight for each entry of the qspn (not just rtt and latency):
	- what to use to get the bandwidth of a network interface?
	  Use `iperf' to measure once the max link bw, then monitor with
	  iptables the link and calculate the used bw.
	- See http://lab.dyne.org/Ntk_bandwidth_measurement
	  
- Compressed Netsukuku pkts: modify pkts.c to compress packets which are
  bigger than X and have the PKT_COMPRESS flag set. Use zlib.

- Port the kernel route code for *BSD: take a look at rt_ioctl.c and
  rt_socket.c of quagga.

- API for the syncronization of the maps the daemon. A third party program,
  might want to have always the latest maps. 

- Write the documentation for the code that can be used by other
  programs. (By the way it is already commented.)

- xmalloc.c: Implement a "wrapper heap". We do a big malloc() at the start and
	     then we manage personally it, in this way we avoid the huge
	     overhead of malloc.
	     
- pkts.c: input_buffer, output_buffer for all the connections: we use them as
	  queue for the incoming and outcoming packets.
	  
- Gnodes contiguity
	- gnode re-hook
		- When we have two different gnodes A and C, and
		  then B hooks to A, nothing happens, since C, doesn't
		  receive any qspn_pkt
		- test: two (g)nodes with the same IP
			- currently only in particular situations the rehook
			  isn't possible: A - A,  A - B - A.
	
	- Challenge
		- RSA between rnodes: the nodes which are already hooked ask
		  for the public key to the node which is hooking.
		- Creation of the problem.
		- Resolution of the problem.
		- Diffusion of the reply.
		- Reject of challenge for X time after a first challenge has
		  been completed.
		- Do just one challenge at the same time, reject/delay all the
		  other which came later.
		- If the challenge was rejected/delayed wait the right amount
		  of time and retry.
		- Ban of gnodes which lost the challenge ?
		- Challenge between two gnode not contiguous, which have the
		  same gid.


*
**
***		LOW PRIORITY
**
*	

- Interactive shell/console. Some commands that should be implemented:
	  "stats" gives statistics, 
	  "rnodes" show the list of rnodes,
	  "int_map" dumps the internal map in a ASCIIful way,
	  "ext_map", "bnode_map", "andna_cache", ...,
	  "flush rhcache"

- renice the NetsukukuD process?

- small memory: if the system has <= X Mb of free memory, switch on dumb mode.
  In this mode NetsukukuD keeps only the list of rnodes and forwards every
  request to one of them. The lcl_cache is kept too.

- option to disable the modification of the routing table

- option to change on runtime the wait-times of the QSPN, radar, etc...
	-normal, -high, -low

- option (both on command line and in netsukuku.conf) to disable the saving of
  caches. (the keyring will always be saved).

- Change with something else the eliminable fatal() calls in netsukuku_hook()

- Ipv6 support: use ff05::23 for multicast. qspn_gnode_count isn't IPv6
  compatible!

- Test request.c

- use PREFIX in the man pages
