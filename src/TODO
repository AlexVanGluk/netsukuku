		[HIGH PRIORITY] 

- Implement all the NTK_RFC: http://lab.dyne.org/Netsukuku_RFC

- Internet Gateway Search
	- igw_add_node in tracer
	- igw_del_node in qspn_remove_deads
	- free server_opt
	- solve NAT multihome problem

- Gnodes contiguity
	- Nodes count in the qspn_pkt which traverses gnodes	  [  50% ]
	- gnode re-hook
		- test: two (g)nodes with the same IP
			- currently only in particular situations the rehook
			  isn't possible: A - A,  A - B - A.
		- restricted mode && rehooking: problems?
			- maybe yes! In restricted mode filter all the other
			  IPs which aren't in private classes
		- rehook() function				  [  55% ]
			- new gid based on the hash of the same gid, when
			  all the other gnodes are full.	  [  55% ]
			- ignore the rnodes of the previos gnode. [ 100% ]
			- at least one qspn_round must be passed. [ 100% ]
			- call rehook() from tracer_store()	  [ 100% ]
		- timed re-hook: the node waits that its rnodes, which are
		  nearer to the other gnode, do the re-hook first.[ 100% ]
		- merging of ext_maps				  [  65% ]
	
	- Challenge
		- RSA between rnodes: the nodes which are already hooked ask
		  for the public key to the node which is hooking.
		- Creation of the problem.
		- Resolution of the problem.
		- Diffusion of the reply.
		- Reject of challenge for X time after a first challenge has
		  been completed.
		- Do just one challenge at the same time, reject/delay all the
		  other which came later.
		- If the challenge was rejected/delayed wait the right amount
		  of time and retry.
		- Ban of gnodes which lost the challenge ?
		- Challenge between two gnode not contiguous, which have the
		  same gid.

- DNS wrapper: ip -> hostnames
	- -r forward to other /etc/resolv.conf dns server

		[MEDIUM PRIORITY] 

- Restricted mode with 172.16.0.0 and 192.168.0.0.
	- what happens when two different restricted net meet?

- The DNS wrapper, if launched in restricted mode, should forward the query to
  the other nameservers in /etc/resolv.conf if ANDNA told him that the
  hostname is inexistent.

- Multi interfaces multipath: if we can reach a rnode trough multiple
  interfaces, use them all with a multipath route (attribute "random").

- Equalize multipath routes

- Bandwidth weight for each entry of the qspn (not just rtt and latency):
	- what to use to get the bandwidth of a network interface?

- Port the kernel route code for *BSD: take a look at rt_ioctl.c and
  rt_socket.c of quagga.
  
- API for the maps sync with the netsukuku_d daemon.

- Write the documentation for the code that can be used by other
  programs. (By the way it is already commented.)

- Interactive shell

		[LOW PRIORITY]

- Change with something else the eliminable fatal() calls in netsukuku_hook()

- Ipv6 support: use ff05::23 for multicast. qspn_gnode_count isn't IPv6
  compatible!

- Test request.c

- Optimize random_ip() to return valid IPs. A possible solution would be
	to zero all the invalid bits.
