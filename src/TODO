*
**
***		HIGH PRIORITY
**
*	

* (generally these TODOs are already being implemented at the moment)

- bugs
	- In restricted mode, is necessary the configuration of a tunnel-if
	  even if we're not going to use an internet conn?

- SNSD
	- pubkey: automatic deletion request

- update the dependencies list: 
	- depends on iptables
	- lartc
	
- Keep an active tcp connection for each rnode. These sockets will be used to
  send the majority of packets.
  The socket shall be saved in the "struct rnode_list" relative to the rnode.
  	- minimize the use of UDP. Use the UDP only for the radar?

- restore the network when NetsukukuD is closed (call /etc/rc.d/rc.inet1 ?)

- check for other active process when starting

- static compilation

- Flash NetsukukuD into an AP and test it.


*
**
***		MEDIUM PRIORITY
**
*	

- Equalize multipath routes. The `equalize' module is still experimental in
  the kernel.

- bandwidth measurement
	- do not delete an inet-gw if there still bw passing on it.

- Bandwidth weight for each entry of the qspn (not just rtt and latency):
	- what to use to get the bandwidth of a network interface?
	  Use `iperf' to measure once the max link bw, then monitor with
	  iptables the link and calculate the used bw.
	- See http://lab.dyne.org/Ntk_bandwidth_measurement
	  
- Compressed maps: save the files in compressed formats

- Sharing willingness: http://lab.dyne.org/Ntk_IGS

- Viphilama: http://lab.dyne.org/Ntk_viphilama

- Port the kernel route code for *BSD: take a look at rt_ioctl.c and
  rt_socket.c of quagga.

- API for the syncronization of the maps the daemon. A third party program,
  might want to have always the latest maps. 

- Write the documentation for the code that can be used by other
  programs. (By the way it is already commented.)

- xmalloc.c: Implement a "wrapper heap". We do a big malloc() at the start and
	     then we manage personally it, in this way we avoid the huge
	     overhead of malloc.
	     
- pkts.c: input_buffer, output_buffer for all the connections: we use them as
	  queue for the incoming and outcoming packets.
	  
- Gnodes contiguity
	- gnode re-hook
		- When we have two different gnodes A and C, and
		  then B hooks to A, nothing happens, since C, doesn't
		  receive any qspn_pkt
		- test: two (g)nodes with the same IP
			- currently only in particular situations the rehook
			  isn't possible: A - A,  A - B - A.
	
	- Challenge
		- RSA between rnodes: the nodes which are already hooked ask
		  for the public key to the node which is hooking.
		- Creation of the problem.
		- Resolution of the problem.
		- Diffusion of the reply.
		- Reject of challenge for X time after a first challenge has
		  been completed.
		- Do just one challenge at the same time, reject/delay all the
		  other which came later.
		- If the challenge was rejected/delayed wait the right amount
		  of time and retry.
		- Ban of gnodes which lost the challenge ?
		- Challenge between two gnode not contiguous, which have the
		  same gid.


*
**
***		LOW PRIORITY
**
*	

- Interactive shell/console. Some commands that should be implemented:
	  "stats" gives statistics, 
	  "rnodes" show the list of rnodes,
	  "int_map" dumps the internal map in a ASCIIful way,
	  "ext_map", "bnode_map", "andna_cache", ...,
	  "flush rhcache"

- ntk-finger: it would be handy to be able to know some info on a particular
  node. The user puts his node info in /etc/netsukuku/finger.
  $ ntk-finger remote_node_ip
  will print out its /etc/netsukuku/finger.
  
- renice the NetsukukuD process?

- small memory: if the system has <= X Mb of free memory, switch on dumb mode.
  In this mode NetsukukuD keeps only the list of rnodes and forwards every
  request to one of them. The lcl_cache is kept too.

- better memory utilisation: see MAXMSGSZ, PKT_MAX_MSG_SZ, pkt_verify_hdr(), 
			     pkt_uncompress(), andns_uncompress().
	- The maximum size of an uncompressed or compressed packet must be
	  proportional to the total free memory reserved to the daemon.
	- pkt_uncompress() must be able to drop the packet if there's no
	  free memory available. The same must be done by pkt_recv() and
	  other similar functions.

- option to disable the modification of the routing table

- option to change on runtime the wait-times of the QSPN, radar, etc...
	-normal, -high, -low

- option (both on command line and in netsukuku.conf) to disable the saving of
  caches. (the keyring will always be saved).

- Change with something else the eliminable fatal() calls in netsukuku_hook()

- Ipv6 support: use ff05::23 for multicast. qspn_gnode_count isn't IPv6
  compatible!

- Test request.c

- use PREFIX in the man pages
