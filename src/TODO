		[HIGH PRIORITY] 

- ANDNA:
  - exclude_function
  - find_hashgnode deve sceglie il gid[0] in maniera random
  - Forwarding della richiesta di resolve da parte dei nuovi hash_gnode che
    hanno soppiantato il vecchio (dove e' presente il db).
  - Testare il resolve
  - Testare il reverse resolve
  - Testare il forwarding
  - dns wrapper per mettere 127.0.0.1 in resolv.conf

- ATTENZIONE: route_del e' disattivato per debugging. 

		[MEDIUM PRIORITY] 

- Usare il multipath per i gnode. Ad esempio se un bnode e' collegato con piu'
  nodi di uno stesso gnode esterno li deve mettere come nexthop nella stessa rotta 
  per raggiungere il gnode esterno. Al contrario se ci sono tanti bnode per
  raggiungere uno stesso gnode, bisogna usare sempre il multipath.

- Anti spoof Hook.

- big endian/little endian per gli int nei pkt.

- Portare per *BSD: bisogna usare rt_ioctl.c ed rt_socket.c di quagga
  ( ../othersrc/quagga-*/zebra/ )
  
- API per il sync delle mappe usando il demone netsukuku_d

- Scrivere una guida alle funzioni generali del codice che possono
  essere usate come API.

		[LOW PRIORITY]

- Testare request.c

gmap.c: Ottimizzare la validita' di ip in random_ip(). Una possibile soluzione
        sarebbe quella di azzerare i bit invalidi.
hook.c: ottimizzare lo spazio di free_node: invece di usare una serie di u_char
        free_nodes, si usano MAXGROUPNODE bits, ed ognuno si setta o no. (Usare
        asm/bitops.h set_bit, clear_bit..., is_set)
broadcast: Tenere in considerazione il gttl.
hook.c:    anti spoof hook

		[ CURRENT TESTS ]
	
12%, krnl_rule.c
19%, request.c
56%, qspn.c
50%, tracer.c
82%, radar.c
83%, route.c
86%, bmap.c
91%, krnl_route.c
93%, pkts.c
94%, gmap.c
95%, netsukuku.c
94%, map.c
95%, inet.c
98%, hook.c
99%, daemon.c
99%, if.c
100%, accept.c
100%, ipv6-gmp.c
100%, libnetlink.c
100%, ll_map.c
100%, llist.c
100%, log.c
100%, misc.c
100%, qspn-empiric.c
100%, xmalloc.c
