/*
 *
 *			THIS IS UNDER COSTRUCTION
 *			  IT IS NOT COMPLETE
 *		       READ IT AT YOUR OWN RISK
 *		    If you want to help in the italian->english traslation
 *		    send a mail to alpt (@freaknet.org)
 */



				    Netsukuku
			
			- Cl0se th3 w0rld, OpeN th3 NeX7 -




La Rete, Tao della conoscenza
che unisce il molteplice nell'uno,
deve rinascere libera,
ed avvolgere in un caldo abbraccio
la dolce madre Gaia.

Questo e' il risveglio, 
il risveglio di tutti noi che finora 
siamo vissuti immersi nella nebbia,
braccati dalla chimera di un putrefatto Wired,
e' il nostro risveglio.

Unitevi e non abbiate timore,
le porte sono aperte,
la Rete ci attende.
								(AlpT)

--								

 -1. Preface

  0. The old wired

  1. The Pure Wired
  
  2. The Netsukuku wired
  
  	2.1  No name, no identity
	2.2  Gandhi
	2.3  Self Control
	2.4  So, WTF is it?
	2.5  Other implementations
  	2.6  The born
  
  3. Netukuku Protocol v7: the seventh son of Ipv7

	3.1  #define Npv7
	
  4. Npv7_II: Laser Broadcast
  
  5. Npv7 Hybrid Theory: the final way
  
  	5.1  QSPN: Quantum Shortest Path Netsukuku
  		5.1.1  QSPN screenshot
	  	5.1.2  Continual qspn starters
		5.1.3  The Qspn sickness: RequestForRoute
		5.1.4  Qspn round
		
	5.2  Npv7_HT Hook & Unhook
		5.2.1  Qspn Hook & Unhook
		
	5.3  The truly Gnode^n for n<=INFINITE
		5.3.1  Groupnode: one entity
		5.3.2  Gnode fusion
	
  6. Broadcast: There can be only one!
  
  	6.1  Delayed Fireball: groupnode broadcast.
	6.2  Tracer pkt: one flood, one route
	
  7. ANDNA: Abnormal Netsukuku Domain Name Anarchy
 
 	7.1  ANDNA Metalloid elements: registration recipe
  		7.1.1  ANDNA hook
		7.1.2  Don't rob my hostname!
		7.1.3  Count again
		7.1.4  Registration step by step
		7.1.5  Endless rest and rebirth
		7.1.6  Hash_gnodes mutation
		7.1.7  Yaq: Yet another queue
		
  	7.8  Hostname resolution
		7.8.1  Distributed cache for hostname resolution
		7.8.2  noituloser emantsoh esreveR
		
	7.9  dns wrapper
	  
  8. Heavy Load: flood your ass!
  
  9. Spoof the Wired: happy kiddies
  
  10. /dev/Accessibility
  
  11. Internet compatibility
  
  12. Implementation: let's code
  
  13. What to do
  
  14. The smoked ones who made Netsukuku
  
--

 -1.  Preface

  This document and the relative source code are available on:
  http://netsukuku.freaknet.org


  0.  The old wired
  
  Internet it's a hierarchic network managed by multinational companies and 
  organizations supported by governments. Each bit of Internet traffic passes
  through their backbones and routers.
  The well-deserving Internet Service Providers give the connectivity to all of
  the poor humans, who are in the lowest rank of this hierarchic pyramid,
  warranting, in this way, the global shared ownership of Internet and its
  free access, obviously, in accordance with the rightful and wise principle
  of equality. They ask, in exchange, a "small" money fee to obtain the right to
  join this network. Beside that, the information, the knowledge and
  the communication don't surely grow as spontaneous fruits on the trees.
  Thank to their generous service, about 600 million of people can be
  connected to the great, free and anonymous network.
  To the remaining 5 billion and 400 million of people, who cannot allow
  themself to this luxury, they say to try in another time, when there will be
  no more wars and the peace will rule.

  Going back to the multinationals: what will happen if one
  of them or an ISP decides to no more supply the service? The answer is
  simple: entire nations will be immediately cut out of the Internet.
  Paradoxally Internet was born with the intent of warranting a secure
  communication, unattackable between the various nodes of the network.
  And what will happen if one of these multinationals will stipulate a secret or
  public agreement with some governments to control the data traffic and trace
  back real or presumed "terrorists"? The traffic will be traced back,
  analysed and the potential "terrorists" submitted, without any restrictions,
  to unlimited controls.

  The centralised and hierarchical structure of Internet creates, as a
  consequence, other identical systems, which are based on it, i.e. the DNS
  The servers of the Domain Name Servers are managed by different ISP, as
  well, and the domains are literally sold out and the  of a centralised
  system remain unmutated.
  This kind of structure allows, in a very simple and efficient way, to
  physically localise any computers, which are connected to Internet, in a
  very short time and without any particular efforts.
  In China, the whole net is constantly watched by several computers which
  filter the Internet traffic: a Chinese will never be able to see or came to
  know about a site which contains some keywords censored by the government.
  And if he'll try to express his own ideas on the net, in spite of what the
  policy or the government is, he will risk the death penality.
  
  Internet was born to satisfy the military needs of security for the
  administration of the American defence. And during the time its basic
  structure never changed and never will change.
  Freedom of communication and information on Internet will always be denied:
  in order to communicate each other we'll always be obliged to ask the
  permission of the central authority and ask for the support of big
  multinationals, and in this way they'll continue to expand their own
  kingdom.
  If the destiny of all the efforts to make Internet the medium of communication --per  eccellenza--
  is to fail, then there is no any other solution than change it.
  How?
  With a distributed, decentralised and fully efficient net, which will never
  be under control of any governments.
  
  1.   The Pure Wired
  
  A neural net, a web, a social network, a fishing net, are pure nets.
  The nature itself is, indeed, the universe in its whole, from the
  infinitely small to the infinitely big, are pure nets.
  
  --  In all the nets that can be found in nature no any centre of --
  In tutte le reti esistenti in natura non esistono centri di "smistamento del
  traffico" della rete, perche' non sono di alcuna utilita'.--
  -- --
  The power and efficiency of this kind of nets is such because of their
  simplicity, therefore no any complications can be found in them.
  
  In a pure net every node has the function of router and then there aren't
  dedicated routers, indispensable, on the contrary, to the other hierarchic
  nets.
 
  The necessary and sufficient condition in order to consider a node belonging
  to a pure net is the connection to at least another node.
  In this way all the nodes of the net be connected to each other.
  If, for example, the node (A) (see the picture below) is sending a message
  to the node (Y), before it will send it to (C), the node (C) will send it to
  (E), then to (F) and at the end it will reach (Y).
  Let's recap: (A)-->(C)-->(E)-->(F)-->(Y).


				         (L)
				          |
				          |
			(A)----(B)-------(H)
			 |			     (T)
			 |			      |
	  (G)----(E)----(C)----(D)-------------------(S)
	          |		|
   	          |		|				  (L1)
	         (F)---(Y)--(1)	|				   |	
		 		|				   |
				|				   |
		       (R)-----(M)---------(Q)		  (Z)----(76)	
			      / | \			   |	
			    /	|   \			   |	
		       (P)/	|     \(O)----------------(U)----(V)
			  	|	|			  |
     (5)---------------------- (N)	|			  |
      |					|			  |
      |		       (9)     		|			 (X)
      |			|	       (20)
     (3)---------------(4)-----(8)
     
 				-| A possible portion of a pure net |-


  2.   The Netsukuku wired
  
  Netsukuku is a pure net which exploits the chaos, it generates and sustains
  itself autonomously, having the shape of a fractal.
  The fusion of pure net with fractals and chaos is the characteristic which
  allows to Netsukuku to be a diffused and distributed, not centralized,
  anonymous, anarchical, not controlled and autonomous net.

  2.1  No name, no identity
  
  Inside Netsukuku everyone, in any place, at any moment, can hook immediately
  to the net without coming trough thousands bureaucratical obstacles, which
  cannot be overpassed.
  Moreover, every elements of the net is extremely dynamic and it's never the
  same. The ip address which identify a computer is chosen randomly,
  therefore it's impossible to associate it to a particular physical place,
  and the routes themselves, been composed by a huge number of node, show the
  tendence to have such a high complexity and density to make the trace of a
  node a titanic task.
  Since there isn't any contract with any organizations, the speed of the data
  transfer is uniquely limitated by the actual tecnology of the network cards.


  2.2  Gandhi

  Netsukuku is anarchical. It generates itself and can stand alone.
  A node hooks to Netsukuku, the net automatically rewrites itself and all the
  other nodes known which are the fastest and more efficient routes to
  communicate with the new arrived.
  The nodes don't have privileges or limitation, when compared with other
  nodes, they are part of the net and give their contribution to its expansion
  and efficiency.
  The more they increase in number the more the net grows and becomes perfect.
  In Netsukuku there is no any differences among private and public nets and
  talking about LAN became meaningless.

	
  2.3  Self Control

  Netsukuku can be neither controlled nor destroyed because it is totally
  decentralized and distributed. The only way to --guard-- or demolish
  Netsukuku is knocking physically down each single node which is part of it.

  Being Netsukuku a distributed and not centralised net, it is possible to
  implement real distributed systems on it, e.g. the Abnormal Netsukuku Domain
  Name Anarchy (ANDNA) which will replace the actual hierarchic and
  centralized system of DNS.
  
  2.4  So, WTF is it?
  
  Netsukuku is a mesh network or a p2p net composed by a net protocol for
  dynamic routing called Npv7_HT.
  Actually there is wide number of protocols ed algorithms for the dynamic
  routing, --ma a differenza-- of the Npv7_HT they are solely utilized to
  create small and medium nets. The routers of Internet are also managed by
  different protocols as the OSPF, the RIP, or the BGP, based on different
  classical algorithms, able to find out the best path to reach a node in the
  net.
  These protocols require a very high waste of cpu and memory, this is the
  reason why the Internet routers are computers specifically dedicated to
  this purpose. It would be impossible to implement one these protocols in
  order to create and maintain such a net as Netsukuku is, where every each
  node is a router by itself, because the map of all the routes would require
  a space, on each pc connected to the net, of about 1 hundred Gb.
  
  The Npv7 structures the entire net as a fractal and, in order to calculate
  all the needed routes which are necessary to connect a node to all the other
  nodes, it makes use of a particular algorithm called
  Quantum Shortest Path Netsukuku (QSPN).
  A fractal is a mathematical structure which can be compressed up to the
  infinite, because inside it, every part itself is composed by the same
  fractal. Thus there is a high compressione of a structure which can be
  infinitely expanded. This means that we need just a few Kb to keep the whole
  Netsukuku map.
  On the other hand, the QSPN is a meta-algorithm in the sense that it
  doesn't follow any predefined mathematical instructions but exploits the
  chance and the chaos, which both don't need any computation. In other words,
  also a simple calculator can work using the QSPN to be connected to
  Netsukuku.

  2.5  Other implementations

  Netsukuku is not restricted solely to the creation of a net of computers, it
  is a protocol which implements a pure net, and alike every net protocol can
  be used in all the situations in which it's necessary to connect different
  nodes to each other.
 
  Let's take in exam the case of mobile phones. Also the mobile phone net is a
  hierarchic and centralised net. Thousands of nodes hook to a same cell,
  which will sort the traffic to the other cells and these, finally, will send
  the data to the destinator-nodes. Well, Netsukuku can be used also by
  mobile phones, making pointless the existence of all the mobile
  telecommunication companies.

  This can be applied to all the systems of communication which are used
  nowadays. 
  
  2.6  The born


  The story of how the idea of Netsukuku was born is quite a long and
  complicated story.
  In the far 2003, a crew of crazy freaks started to think about Ipv7: a net
  in which all the packets was sent in broadcasted, compressed with the zlib7,
  an algorithm which could compress all the existent Internet into just
  32 byte. In Ipv7 the nodes were devoid of an ip address. 
  In this way we could obtain an extremely decentralised and totally free net.
  Those people were really happy after the first draft of the RFC.
  One year later, the project --si perde tra le infinite diramazioni del--
  --  tempo , ma dopo non molto la polvere viene scrollata dal grande libro--
  --  dell'Ipv7. --
  We started to delineate the idea of the implementation of a pure net. Month
  by month the net became more and more refined, and the project became
  something concrete.
  <<But it has also to support a sort of anti-flood and anti-spoofing>>.
  <<Yep! And the main target is to make the routes always different from each
  other >>.
  <<Yea, yea, and why don't we make found out a way to abolish all the central
  servers?>>.
  Other three months passed by and after many mystical meditations, the
  theoretical kernel was ready. The algorithms were defined.
  We started to code. The curse of the protocols coders of Pharaon
  Mortedelprimogenito invaded the Netsukuku code. The delirium is the right
  reward to all those who dare to create protocols of pure nets. 
  In spite of all, exactly after one year and after fourteen thousand lines of
  code, Netsukuku Beta version was ready and immediately presented at the
  National Hackmeeting 2005 in Naples. The ANDNA was completed and
  documented. 
  What's left sleeps in our minds and still have to become.

  3.   Netsukukuku protocol v7

  Netsukuku uses its own protocol, the Npv7 (Netsukuku protocol version 7),
  which derives from three different previous versions.
  The first one was quite similar to the actual dynamic routing protocols:
  the network was in fact divided into several groups of nodes, and every
  single node had a distinct map of the entire network.
  This system, absolutely not optimal, cannot be employed by Netsukuku 'cause
  it needs continuous and subsequent updates of the early map, and each update
  will bring an overload in the net.
  Moreover, each time the map changes, it's necessary to recalculate all the
  routes.

  3.1  #define Npv7

  The basic definitions used in Netsukuku are: 

  src_node: Source node. It is the node who send a packet to the dst_node.
  dst_node: Destination node. It is the node which receives the packet from
	    the dst_node.
  
  r_node: Remote node, given a node X, it is any other node directly linked to
	  X.
  g_node: Group node, a group of nodes, or a group of a group of nodes, and so
  	  on.
  b_node: Border node, a node connected to rnodes of different gnode.
  h_node: Hooking node, a node hooking to Netsukuku.
  
  int_map: Internal map. The internal map of the node X contains the
	   informations about the gnode, which the node X belongs to.
  ext_map: External map. The external map contains the informations about the
	   gnodes.
  bmap / bnode_map: Border node map. It's the map which keeps the list of
		    border_nodes.

  quadro_group: A node or a groupnode located at any level, disassembled in
	        its essential parts. 


  4.   Npv7_II: Laser Broadcast

  Npv7_II is the second version of the Npv7.
  Netsukuku is divided into many smaller groupnodes, which contains up to six
  hundred nodes each and every node will solely have an external map.
  All the groupnodes are grouped into multi-groupnodes, calle quadro
  groupnodes.
  In order to create a new route and connect to a given dst_node, the
  src_node, using the external map, firstly tries to find out the best path to
  reach the destination gnode, which the dst_node belongs to.
  In this way the founded route is stored in the pkt broadcasted inside the
  gnode, which the src_node belongs to.
  The border_nodes of the gnode of the src_node receive the pkt and check if
  the next gnode, to which the pkt has to be broadcasted, is the proper
  neighbor gnode. If the condition is true, the border_nodes broadcast the pkt
  to that same neighbor gnode. Otherwise the pkt is dropped.
  And so on...
  In this way the packet will reach the destination gnode.
  When the dst_node receives the pkt it has just to set an inverse route, using
  the route already stored in the pkt.
  The Npv7_II and its previous version are not utilised, but they are just the
  theoretical base of the Npv7_HT, the actual version of the Netsukuku
  protocol.

  5.   Npv7 Hybrid Theory: the final way

  From the union of the Npv7 and Npv7_II 
  Npv7 Hybrid Theory was born from the union of the Npv7 and Npv7_II.
  This bew version, exploits the advantages of both the internal map and the
  laser broadcast and in this way it can overpass their limits.
  In Npv7_HT the maximum number of nodes, present in a group node
  (MAXGROUPNODE) is equal to 2^8, thus the groupnodes are relatively small.
  The main change in Npv7_HT is about its own essence, in fact, it's based on a
  algorithm appositely created for Netsukuku, which is called
  Quantum Shortest Path Netsukuku, which allows to obtain at once all the
  informations related to the complete situation of the gnode, all the best
  routes, the reduction of the load of the gnode, an efficient
  management of high dynamic gnodes and moreover it's not even necessary to
  authenticate each node.
  
  5.1   QSPN: Quantum Shortest Path Netsukuku


  In Netsukuku, as well as in Nature, there is no any need of using
  mathematical schemes, created by the limitated human logic.
  Netsukuku exploits the chaos.
  The use of a map, for a protocol of dynamic nets, can create a lot of
  troubles, since it has to be continuosly updated. The solution is simple: to
  avoid totally the use of maps and make every broadcasted request a
  tracer_pkt (See 6.2 Tracer pkt).
  In this way every node, which will receive the pkt, will known the best
  route to reach the src_node and all the nodes which are at the middle of the
  route itself, it will record these informations inside its internal map, it
  will add its own entry inside the tracer_pkt and will continue to broadcast
  the pkt.
  The left problem is: in order to obtain all the routes for all the nodes
  it's necessary that all the nodes broadcast a tracer_pkt. Actually this
  problem doesn't exist at all. In fact, with the tracer_pkt we can obtain
  also the routes for the middle-nodes: that means we need a smaller number
  of n packets, where n is the number of nodes.

  If every time a node receives a tracer_pkt, it sends it back to the
  src_node, in this way we are sure that all the nodes can receive all the
  possible routes. By using this system we obtain the same result achieved by
  making every node send a tracer_pkt.

  --da leggere--
  For those which have in mind the wave physic, the working of the qspn can be
  easily understood. If we throw a pebble in a mirror of water, contained in a
  basin, from the point of impact circular waves begin to propagate themself.
  Each wave generates a child wave that continues to spread and to generate
  child waves which generates childs, and so on...
  When a wave hits the borders of the basin, it is reflected and goes back to
  the start point; the same happens if the wave meet an obstacle.
  The qspn_starter is the pebble thrown inside the groupnode ed each wave is a
  tracer_pkt. Each child wave carries with itself the information of the
  parent wave. When the wave arrive in an extreme_node (an obstacle or a dead
  road), the qspn_open (the reflected wave) starts.
  
  The QSPN is based on this principle. To begin the tracing of the gnode, any
  node sends a qspn pkt called qspn_close; this node becomes so a
  qspn_starter.
  A qspn pkt is a normal tracer_pkt, but its broadcasting method is lightly
  different from the normal one.
  Each node which receive a qspn_close "closes" the link from which the pkt
  was received and sends the pkt to all its other links. All the following
  qspn_close pkts, which will arrive to the node, will be sent to all the
  links not closed yet.
  When the qspn_close is totally diffused, some nodes will have all their
  links closed. These nodes will be the extreme_nodes, which will send another
  qspn_pkt to reply (called qspn_open). The qspn_open contains all the
  information already stored in the last receveid qspn_close. The
  extreme_nodes will send the qspn_open to all their links, except the one
  from which they have received the last qspn_close and to whom they'll send
  an empty qspn_open.
  The qspn_open is a normal qspn_pkt, so it "opens" all the links in the same
  way of the qpsn_close. The nodes, which will have all their links opened
  will do absolutely nothing, in this way the end of the qspn_close is
  warranted.
  A qspn_open pkt has also a sub_id, a number that identifies, in the internal
  map, the extreme node, which has generated the qspn_open pkt itself. The
  sub_id, which remains unmodified in all the child qspn_open pkt generated
  from the first packet, is used to manage simultaneusly more qspn_pkts, since
  each extreme_node generates one qspn_open and each of them has to be
  independent from the others.
  All the nodes, which have only one link are surely e_nodes (extreme nodes),
  in fact, when they receive a qspn_close they are already closed.

  A node, after it sent a qspn_open, cannot reply anymore to any qspn_pkt that
  it'll receive, thus it will send no more qspn_pkts.
  The qspn_starter, the node, which has triggered the qspn, acts as a normal
  node but it will not send qspn_opens, since it already sent the very first
  qspn_close, moreover it will use, to update its own map, all the qspn_closes
  it will receive excepting the ones which were sent by itself and that which
  crossed already more than one hop; doing so, even if there is more than one
  qspn_starter the stability is maintained. The in-depth description of the
  qspn_starter is in the following paragraph 5.1.1.

  At the end the total number of packets which are sent in broadcast are equal
  to the number of e_nodes, which are 2 for each cyclic net segment and 1 for
  each single non-cyclic segment.

  Each time a tracer_pkt goes trough the net, the information it carries about
  the crossed routes are stored by all the nodes that receive it.
  A node will probably receive different routes to reach the same node, but it
  will memorize only the best MAXROUTES (10) routes. 
  
  The qspn_pkt id, which is stored in the pkt itself, is at the beginning set
  to 1 and it's incremented of one each time a new one is sent by any node.
  Because of that, all the nodes know the current qspn_pkt id. Each time a
  node wants to update globally the internal or external map, it sends a
  qspn_close, but only if it hasn't received in the previous QSPN_WAIT seconds
  another qspn_close.
  If two nodes send, at the same time, a qspn_close, they will use the same
  pkt id because they don't know that another one, with the same id, was
  already sent; in this case the working of the qspn doesn't change, in fact,
  if the two qspn_pkt were sent from places very distant from each other, the
  qspn_pkt will diffuse spread more rapidly.

  When a node downloads the internal map from another node it has to restore
  the map before making use of it. To do that the node has to just to insert the
  r_node, from which it has downloaded the map, to the beginning of all the
  routes. If the node downloads the map from more than one rnode, it will have
  to compare all the routes and choose the best one. The resulting map will
  have all the best routes.
  
  The routes of the internal and external maps will be always copied in the
  kernel routing table. In this way it will not be necessary to create each
  time the route to reach the destination node.
  
  5.1.1  QSPN screenshot
    
        (A)-----(B)
      /  | \     |  \
   (E)   |   \   |  (F)
      \  |     \ |  /
        (C)-----(D)
  
  Summing up, all the extreme nodes shall send a tracer_pkt, be we cannot know
  who they are. In the above picture it's easy to point them out, because,
  indeed, the map is drawn, but in the reality (inside the Netsukuku code) a
  topologic map doesn't exist at all, so we cannot know where a group of nodes
  begins and where it ends.
  
  Here it is what happens, in a theoretical simulation, if the node E sends a
  qspn_close:
  E has sent the first qspn_close of a new qspn_round, so it is now a
  qspn_starter.
  Let's consider the case when the node A receives before the C the
  qspn_close.
  A closes the link E, sends the pkt to B, C and D.
  C receives the pkt, closes the link E, sends it to A and D.
  C receives the pkt from A, closes the link.

  B e D have received the pkt and close the respective links.
  Let's consider the case when B sends the pkt before F.
  D, immediately, sends it to F, but at the same time F sends it to D.
  D receive the pkt from B too.
  D and F have all the links closed.
  They send a qspn_open.
  The qspn_open propagates itself in the opposite sense.
  The qspn_open ends.
  Each node has the routes to reach all the other nodes.

  Generally, the basic topology of a map for the qspn is a rhomb with the
  nodes at the vertexes, then, to have more complex topology it's possible to
  add other rhombs united each other from the vertexes.

  5.1.2  Continual qspn starters

  Se piu' qspn_starter che lanciano un qspn sono contigui fra loro allora
  il funzionamento del qspn varia leggermente. Un gruppo di nodi qspn_starter 
  e' contiguo quando tutti i suoi nodi sono collegati a nodi che sono a
  loro volta dei qspn_starter. In questo scenario i qspn_starter continuano a
  forwadare tra di loro solo i qspn_close mandati dai qspn_starter; si comportano
  quindi come dei normali nodi, ma non appena ricevono dei pacchetti provenienti
  dall'esterno del gruppo contiguo di qspn_starters ritornano a seguire le loro
  istruzioni originarie. Quindi A manda un qspn_close, B ha mandato pure un
  qspn_close, quando B riceve il qspn_close di A lo forwarda come un normale
  tracer_pkt con la flag BCAST_TRACER_STARTERS che si diffonde solo tra gli
  altri starter.
  Il motivo di tutto questo deriva dal fatto che in quel gruppo contiguo di 
  nodi, ogni singolo nodi manda un tracer_pkt, quindi, i qspn_pkt vengono
  declassati a normali tracer_pkt.
  
   
  5.1.3  The Qspn sickness: RequestForRoute
  
  /* Da codare, e non realmente necessario */
  L'unico grande difetto di qspn e' l'impossibilita' di avere molte piu' rotte
  per raggiungere uno stesso nodo. Con Qspn si e' sicuri di avere solamente
  la rotta migliore, e basta. In realta' qspn puo' anche dare infinite
  rotte, basta che si lascia circolare il broadcast all'infinito (^_-). Per
  evitare sovraccarichi, complicazioni, segfault, bla, bla, etc... e'
  meglio lasciare tutto cosi' com'e'. Ma allora che si fa per curare la sua
  deficenza immunitaria?  Si usa il RequestForRoute! Il RFR verra' usato ogni
  volta che un nodo si connette ad un altro e non influira' affatto sul questo
  collegamento, proprio perche', viene fatto girare separatamente. 
  Ecco cosa succede:
  il nodo manda a tutti i suoi rnode una richiesta RFR per una determinata
  rotta, questa richiesta contiene anche il numero di sub richieste che gli
  rnode devono mandare ai loro rnode. In pratica il nodo decide quante rotte
  ricevere e si calcola il numero di sub richieste che dovranno mandare i suoi
  rnode: subrfr=(total_routes-r_node.links)/r_node.links; Dopo invia la rfr.
  I suoi rnode dopo avergli mandato la rotta che loro usano per raggiungere il
  dst_node specificato nel rfr_pkt mandano allo stesso modo un rfr che pero'
  ha total_routes pari a subrfr. Gli rnode degli rnode eseguiranno la stessa
  procedura e risponderanno direttamente al nodo interessato.

  5.1.4  Qspn round

  Se un nodo riscontra un cambiamento attorno a se', ad esempio un suo
  rnode e' morto oppure l'rtt che lo distanzia dal suo rnode e' cambiato
  considerevolmente, allora mandera' un QSPN. Per evitare che vengano creati
  dei QSPN continuamente, il nodo deve prima verificare che il QSPN_WAIT_ROUND
  (60 secondi) sia scaduto. Il QSPN_WAIT_ROUND scade nello stesso momento per
  tutti i nodi appartenenti allo stesso gnode. Per far si che i nodi siano
  sincronizzati ad i nodi che si agganciano al gnode viene dato il numero
  di secondi che sono passati dal precedente QSPN, in questo modo tutti i
  nodi sapranno quando avverra' la prossima scadenza perche' avverra' dopo
  (current_time-prev_qspn_round)+QSPN_WAIT_ROUND.
  Quando un qspn_starter manda un nuovo qspn_pkt, incrementa l'id del
  qspn_round di 1. 
  Se il nodo che riceve un qspn_pkt, vede che il suo id e' maggiore del
  qspn_round id precedente che ha memorizzato, allora vuol dire che ha ricevuto
  un nuovo qspn_round; in questo caso aggiornera' il suo id locale e il suo
  qspn_time ( la variabile che indica quando e' stato ricevuto/mandato l'ultimo 
  qspn ).
  Per aggiornare il qspn_time, dovra' settarlo a 
  current_time - somma_degli_rtt_contenuti_nel_tracer_pkt.
  
  5.2  Npv7_HT Hook & Unhook
  
  Un nodo, per joinare in Netsukuku, deve agganciarsi ai suoi rnode.
  L'hook in Netsukuku non si riferisce ad un aggancio alla rete "fisico",
  poiche' si presuppone gia' che un nodo sia linkato ad altri (r)_node.
  Quando un nodo si aggancia significa che comunica con un il suo rnode piu'
  vicino, se non gli risponde ne sceglie un altro. In pratica durante l'hook,
  il nodo si prende la mappa interna, quella esterna, la mappa dei boarder node,
  e si sceglie un ip libero. A questo punto fa ufficialmente parte della rete,
  quindi manda un normale tracer_pkt. I suoi rnode manderanno in seguito, un
  qspn.
  
  Ecco cosa avviene piu' in dettaglio:
  Il nodo si prende un ip compreso tra 10.0.0.1 <= x <= 10.0.0.1+256,
  rimuove le reti di loopback dalla tabella locale di routing e setta come
  default gateway l'ip scelto.
  Il primo passo e' quello di lanciare il primo radar per vedere quali sono i
  suoi r_nodes. Se non ci sono rnodes, crea un nuovo gnode e l'hook termina qui.
  Poi chiede all'rnode piu' vicino la lista di nodi liberi (free_nodes)
  presenti nel gnode dell'rnode. Se l'rnode non accetta la richiesta (il gnode
  potrebbe essere pieno), il nodo chiede la lista ad un altro rnode.
  Dai free_nodes ricevuti sceglie un ip e lo setta all'interfaccia di rete,
  modificando il default gw.
  A questo punto richiede la mappa esterna allo stesso rnode da cui ha preso la
  list di nodi liberi. Usando la lista di free_nodes vede se deve creare un nuovo
  gnode. Se non deve, prende l'int_map da ogni r_node.
  Unisce tutte le int_map ricevute in un unica mappa, in questo modo ha gia'
  tutte le rotte. Infine, si prende la bnode_map.
  Se tutto e' andato a buon fine, rilancia un secondo radar, manda un semplice
  tracer pkt ed aggiorna la sua tabella di routing. Fin.
  
  5.2.1  Qspn Hook & Unhook

  Un nodo, dopo essersi agganciato al gnode, non deve far altro che mandare
  un tracer pkt. In questo modo tutti i nodi avranno gia' la rotta esatta
  per raggiungerlo, aggiorneranno qualche rotta e saranno felici. Poi per
  quanto riguarda le rotte secondarie ci pensera'il round successivo di QSPN.
  Quando un nodo muore o si sgancia, non dice nulla a nessuno. La morte sara'
  pianta silenziosamente nel cuore degli altri nodi. Ci pensera' il QSPN che
  verra' con il prossimo round a diffondere la triste notizia. Fino a quel
  momento solamente i nodi che cercaranno di contattare il nodo defunto si
  accorgeranno della sua scomparsa.

  5.3  The truly Gnode^n for n<=INFINITE

  Nel mondo ci sono 6*10^9 di persone, se andremo a colonizzare
  altri pianeti arriveremo a circa (6*10^9)^n, dove n e' un numero random > 0.
  E' anche vero che ci estingueremo molto prima in una delle solite stupide
  guerre. In sostanza netsukuku deve provvedere a un numero ENORME di nodi,
  per questo, come gia' sai, si usano i gnode. 
  Ma questo non basta, perche' anche cosi' ci vorrebbero 300Mb circa per 
  tenere l'intera extern map! Come si fa quindi? 
  Si dividono i gnode in ulteriori gruppi, stavolta pero' questi gruppi non
  contengono nodi normali ma degli interi gnode, che vengono considerati dei
  nodi a tutti gli effetti...  Procedendo recursivamente netsukuku puo'
  contenere all'incirca INFINITI nodi.
  Tutto rimane invariato.  
  Per far questo bisogna tenere piu' mappe esterne. Ogni mappa
  conterra' un gruppo di qualche cosa. Questi gruppi di gruppi li continuamo
  a chiamare groupnode. Ogni mappa di groupnode appartiene ad un determinato 
  livello. Quindi il groupnode normale, che racchiude singoli nodi si trova 
  a livello 0, la mappa del primo groupnode di gruppi di nodi si trova al primo
  livello, e la mappa di groupnode di groupnode di groupnode e' al secondo,
  e cosi' via.
  Un nodo per poter contattare qualsiasi altro nodo in qualsiasi parte del
  globo deve avere solamente la sua mappa interna, che non e' nient'altro
  che la mappa a livello 0 e poi le mappe di tutti i livelli superiori in
  cui lui e' presente.  Facendo qualche calcolo con l'ipv4, per usare tutti
  gli ip, si devono usare solamente 3 livelli di mappe. Il che significa che
  prima c'e' il normale groupnode, poi ci sono MAXGROUPNODE di groupnode,
  e infine ci sono MAXGROUPNODE di questi ultimi. Nell'ipv6 invece, abbiamo
  una quantita' abnorme di ip, percio' i livelli ammontano a 16.  Facendo una
  stima approssimativa tutte le mappe esterne dei groups nell'ipv4 occupano
  144K di memoria e nell'ipv6 1996K. Questo significa che nessuno si deve
  preoccupare di usare lo swap!  
  Per trovare le rotte che connettono i vari gruppi verra' usato il QSPN, 
  avevi dubbi -_^ ?  Il qspn verra' ristretto e lanciato per ogni livello, in
  questo modo, ad esempio, trovera' tutte le rotte che legano i nodi
  appartenenti al secondo livello...
  Questo sistema dei livelli in relta' non e' complesso, basta tenere
  presente che il funzionamento della mappa interna in unione a quella della
  mappa esterna ed applicare recursivamente ad ogni grouppo lo stesso concetto.
  Basta considerare ogni grouppo un singolo nodo.  
  Se per raggiungere un groupnode si usa  un range di ip (da ip x ad ip y) 
  nella routing table, allora per poter raggiungere tutti i nodi presenti in 
  netsukuku bisogna tenere nella routing table MAXGROUPNODE*(levels+1) rotte. 
  Consideriamo il caso dell'ipv4 che ha 3 livelli. 
  Intanto un nodo deve avere tutte le rotte per raggiungere tutti
  i nodi all'interno del suo groupnode, percio' gia' abbiamo MAXGROUPNODE
  di rotte, poi dobbiamo aggiungere tutte le rotte per raggiungere gli
  altri groupnode del suo livello superiore, percio' aggiungiamo altri
  MAXGROUPNODE di rotte. Proseguendo arriviamo all'ultimo livello ed abbiamo
  MAXGROUPNODE*(levels+1). Con l'ipv4 abbiamo 1024 rotte, con l'ipv6 4352.
  Tutte queste rotte risiederanno direttamente nel kernel.

  /* TODO: da codare, oppure no. Forse non serve proprio, e in ogni caso si
   * puo' diminuire il numero di rotte in maniera esponenziale diminuendo il
   * MAXGROUPNODE ed aumentando i livelli, ad esempio se un gnode e' composto
   * da massimo 2^2 di nodi allora i livelli sono 16 nell'ipv4 e le rotte
   * diventano 68.
   */
  Questo numero enorme di rotte puo' sembrare oneroso, percio' l'utente puo'
  decidere quanti livelli tenere nel kernel.
  Di default e' presente il livello 0, quindi tutte le MAXGROUPNODE rotte
  per raggiungere i nodi del proprio group_node; i livelli successivi che 
  vengono aggiunti partono dall'ultimo per discendere al secondo. 
  La variabile che contiene il numero di livelli da memorizzare e' chiamata 
  level_routes. Se level_routes e' uguale a zero allora tutti i livelli
  verrano mantenuti nel route table del kernel. 
  Se, ad esempio, e' uguale a 3 ed n rapressenta il numero di
  livelli totali di Netsukuku, allora il kernel conterra' il livello 0, il
  livello n-1, n-2 ed n-3.  Se un livello non e' presente nella krnl route
  table allora la rotta verra' creata al momento da netsukuku quando il kernel
  la richiedera'. Ovviamente piu' livelli si mantengono nel kernel e piu'
  performante e' il tempo di connessione, ma tutto questo va a discapito
  della memoria. Si deve pero' considerare che ormai i computer hanno Gbytes
  di ram e che ogni rotta occupera' al massimo 100 byte (stima molto rozza
  ed approssimativa), percio' con 4352 rotte bisogna usare solo 435200 bytes
  (425k). Davvero una miseria, ma si sa' l'ottimizzazione non e' mai troppa.


  5.3.1 Groupnode: one entity
  
  Per avere il qspn effettivo dei groupnode la storia cambia un po'.
  La differenza tra un groupnode ed un nodo singolo risiede nel fatto che il
  nodo e' un'unica entita' che gestisce i suoi link direttamente da se, il
  groupnode, invece, e' un nodo composto da piu' nodi e i suoi link sono
  gestisti da altri nodi che sono i boarder node. Per rendere il groupnode
  un'unica entita' che si comporti esattamente come un nodo singolo basta che
  tutti i bnode del groupnode comunichino tra loro. Quindi, quando un bnode
  riceve un qspn_close da un altro groupnode, chiudera' il suo link e quando
  avra' tutti i suoi link, con gli altri gnode, chiusi lo comunichera' agli
  altri bnode del suo groupnode. Lo stesso faranno gli altri. In questo modo 
  il qspn_open sara' mandato solamente quando tutti i bnode avranno tutti i 
  loro link esterni chiusi.
  Quando parliamo di groupnode di alti livelli allora un bnode non e' piu' un
  singolo nodo, ma e' a sua volta un gnode. Il procedimento resta invariato:
  questo bnode-gnode e' rappresentato da tutti i suoi bnodes interni.
  Ma come fanno i bnode a comunicare fra loro?
  Ovviamente in modo passivo: quando un bnode chiude tutti i suoi link esterni
  dopo aver ricevuto un qspn_close, setta nel tracer_pkt che sta' per
  forwardare la flag BNODE_CLOSED, in questo modo gli altri bnode, vedendo
  questa flag, incrementeranno il loro contatore di bnodes chiusi. Quando i
  numero di bnode chiusi e' pari a quello dei bnode presenti nel gnode, allora
  verra' mandato il qspn_open.
  Un ultimo accorgimento: quando un bnode riceve un qspn_close mandato da un
  bnode del suo stesso gnode, allora, anche lui si considerera' un
  QSPN_STARTER e forwardera' il pkt senza aggiungere la sua entry, questo 
  perche' il gnode deve essere come un unico nodo; inoltre, i bnode chiudono
  ed aprono solo i link esteri, cioe' quelli che li collegano ai bnode dei
  gnode confinanti.
  Tutto questo discorso vale anche per il qspn_open.

  5.3.2  Gnode fusion

  Quando un nodo crea un nuovo group node, ne sceglie uno completamente random,
  usando quindi, un ip random. Se due gnode, dapprima isolati, per disgrazia
  hanno lo stesso groupnode id, (e quindi lo stesso intervallo di ip), uno
  di loro due deve cambiare; questo significa cambiare l'ip di tutti i nodi
  del gnode. Se il gnode e' di un livello superiore, e' davvero un disastro.
  Per evitare tutto cio', basta che l'ip random, sia unico in tutto il globo!
  La soluzione e' semplice: usiamo degli hash del tempo che diventeranno il
  nostro ip "random". Visto che consideriamo anche i micro secondi, non ci
  saranno due ip uguali in tutto il globo.
  
  6.   Broadcast: There can be only one!
  
  Quando vengono mandati dei pkt in broadcast si deve fare in modo che non
  vaghino in eterno in Netsukuku.  Ogni nodo mantiene una cache composta
  da un numero di slot pari a MAXGROUPNODE. (La cache e' all'interno della
  mappa interna). Ogni slot corrisponde, ad un nodo del g_node. Questo slot
  contiene il pkt_id dell'ultimo pkt broadcast mandato da quel nodo. 
  Quindi:
	u_int brdcast; /*Pkt_id of the last brdcast_pkt sent by this node*/
	
  Un nodo quando riceve un pkt broadcast lo analizza: 
  se vede che il pkt_id e' <= a quello memorizzato nella cache lo rigetta,
  perche' e' sicuramente un pkt vecchio che non deve piu' diffondersi.
  Ovviamente i pkt_id vengono incrementati ogni volta dal src_node.  
  Se il pkt supera questo check allora il nodo esegue l'azione che il pkt
  richiede e forwarda il pkt a tutti i suoi r_node, escludendo quelli che gli
  hanno spedito il pkt.	Se si vuole che il broadcast sia delimitato entro
  un'area di raggio prefissato, basta settare il ttl al numero di hop di questo
  raggio.

  6.1  Delayed Fireball: groupnode broadcast.

  Un nodo che vuole accertarsi che un altro nodo non e' presente nel
  Wired oppure vuole stabilire una rotta con un nodo che ancora non e'
  stato ancora inserito nelle mappe, creera' un pkt con la flag settata a
  "delayed_broadcast". Questo pkt conterra' un messaggio, l'indirizzo di dst e
  il groupnode di dst. Dopo aver forgiato il pkt, si calcolera' la rotta per
  raggiungere il destination groupnode e inviera'. Quando il pkt giungera'
  ad un qualsiasi nodo del dst_groupnode, verra' propagato in broadcast
  _solamente_ all'interno del groupnode. Il dst_node che riceve il pkt puo'
  rispondere in base al contenuto del msg. Puo' per esempio decidere di
  rispondere ad un semplice "AreYouAlive?" oppure puo' calcolarsi la rotta
  che giunge al src_node e stabilire un connessione con lui.
  Ecco cosa si puo' fare con il delayed_broadcast:
  (1) Un nodo puo' creare delle back_connection con un nodo: Crea la rotta
      dopo aver ricevuto il pkt "delayed_broadcast",
      e manda un msg di conferma al nodo src attraverso la rotta. Il src_node
      a questo punto puo' iniziare la connessione utilizzando quella rotta.
  (2) Un nodo puo' anche decidere di entrare in Netsukuku senza far aggiornare
      le mappe di Netsukuku agli altri, in questo
      modo diventa invisibile a tutti, pero' puo' ancora essere contattato,
      ma _solo_ da coloro che sanno che e' Up & running. Si puo' usare
      questo sistema anche per evitare di dover fare da router, infatti,
      essendo invisibili, nessun nodo potra' scegliere un nodo invisibile
      proprio perche' non lo vede. Pero' questo comporta un'instabilita'
      generale, percio' e' meglio che i nodi non usino mai questo sistema.

  6.2  Tracer pkt: one flood, one route

  Il tracer pkt non e' altro che il modo per trovare la rotta migliore
  con il broadcast. Se il pkt che viene mandato in broadcast avra' la flag
  "tracer_pkt" settata allora' ogni nodo che attraversera', aggiungera' in coda
  al pkt il suo ip. Quindi l'intera rotta che il pkt compie viene memorizzata
  nel pacchetto stesso. Il primo pacchetto che arrivera' a destinazione sara'
  sicuramente quello che avra' percorso la rotta migliore, percio' il dst_node
  non fara' altro che settare la rotta memorizzata nel pacchetto ed avviare
  la connessione.  Il tracer_pkt introduce anche un altro subdolo  vantaggio,
  infatti, il tracer_pkt non solo trasporta la rotta migliore per il src_node,
  ma anche quella per i nodi che fanno parte della rotta perche' se questo pkt
  ha davvero percorso la rotta migliore significa che ha anche percorso _TUTTE_
  le rotte migliori per gli hop intermediari. 
  Concludendo, con un tracer pkt possiamo conoscere la rotta migliore per 
  raggiungere il src_node (il nodo che ha spedito il pkt), e conseguentemente 
  le rotte per raggiungere tutti i nodi intermediari.  
  I border_node quando aggiungono la loro entry in un tracer_pkt settano la 
  flag b_node ed aggiungono in coda l'id del gnode con cui confinano se
  appartiene al livello superiore a quello in cui il tracer_pkt si sta' 
  propagando.
  Con questo sistema tutti riceveranno tutte le rotte migliori per raggiungere 
  tutti i nodi del g_node e tutti i g_node confinanti.

  Per ottimizzare al massimo lo spazio utilizzato in un tracerpkt, 
  gli ip vengono storati nel formato IP2MAP e quindi sara' usando 
  un u_char, (1 byte invece di 20).

  
  7.   ANDNA: Abnormal Netsukuku Domain Name Anarchy

  ANDNA e' il sistema distribuito, non gerarchico e decentralizzato, di
  gestione di hostname in Netsukuku. Sostituisce il DNS.
  Il database dell'ANDNA e' sparso in tutto Netsukuku e nel peggiore dei casi
  ogni nodo dovra' usare circa 355 Kb di memoria.
  
  Il funzionamento base di ANDNA si articola nel seguente modo:
  per risolvere un hostname basta calcolarsi il suo hash. 
  L'hash non e' nient'altro che un numero e questo numero noi lo consideriamo
  come un ip. Il nodo che corrisponde a questo ip lo chiamiamo andna_hash_node.
  In pratica l'hash_node, manterra' un piccolo database che associa gli
  hostname, che corrispondono a lui, con l'ip del nodo che ha registrato
  quello stesso hostname.

  
            Nodo X
      ip: 123.123.123.123
      hash( hostname: "andna.acus" ) == 11.22.33.44
					   ||
					   ||
					 Nodo Y
				     ip: 11.22.33.44
			   {	[ Database andna del nodo Y ]	 }
			   {hash_11.22.33.44 ---> 123.123.123.123}


  Le richieste di revoca non esistono, l'hostname viene cancellato
  automaticamente se non viene aggiornato.
 
  7.1  ANDNA Metalloid elements: registration recipe
  
  In realta', non e' detto che l'hash_node esista nella rete, perche' puo'
  essere un ip a caso tra i 2^32 ip disponibili, ed ammesso che esista puo'
  sempre morire e uscire dalla rete. Quindi, per garantire la funzionalita'
  effettiva di ANDNA, ed anche un minimo di backup, gli hostname non vengono
  gestiti da singoli nodi, ma da interi gnode. Il gnode che corrisponde
  all'hash e' l'hash_gnode, all'interno ci sara' anche l'hash_node.
  
  Poiche' gli hash_gnode possono anche non esistere al momento, viene adottata
  una strategia di approsimazione: viene usato il gnode che piu' si avvicina
  all'hash_gnode, che viene chiamato, rounded_hash_gnode, o in forma breve
  rounded_gnode. Ad esempio, se l'hash gnode e' il 210, il piu' vicino a lui
  sara' il 211 e il 209.
  In generale, quando si considera solamente il gnode che  ha accettato una
  registrazione, non si fa differenza tra i due tipi e il gnode si chiama sempre
  hash_gnode.
  
  Per consentire un pronto recupero degli hostname quando un intero hash_gnode
  viene tagliato fuori da Netsukuku perdendo tutti i suoi link, o quando tutti
  i nodi che lo compongono muoiono, si usano dei rounded_gnode di backup.
  Un backup_gnode e' sempre un gnode rounded_gnode, ma mette  a disposizione solo
  alcuni dei suoi nodi per mantenere l'informazione dell'hostname registrato.
  Il numero dei nodi che fanno da backup in un backup_gnode e' proporzionale
  al suo numero totale di nodi (seeds):
 	 if(seeds > 8) { backup_nodes = (seeds * 32) / MAXGROUPNODE ); }
  		else    { backup_nodes = seeds; }
  Il numero di backup_gnodes utilizzati per ogni hash_gnode e' pari a
  MAX_ANDNA_BACKUP_GNODES (2).

  7.1.1	 ANDNA hook

  Quando un nodo si aggancia a Netsukuku diventando parte di un hash_gnode,
  dovra' anche preoccuparsi di agganciarsi ad ANDNA con l'andna_hook.
  Con l'andna_hook si prendera' dai suoi rnode tutti le caches ed i database
  che i nodi di quel gnode posseggono. Ovviamente e' prima necessario che il
  nodo si agganci a Netsukuku.

  7.1.2  Don't rob my hostname!
  
  Un nodo, prima di fare una richiesta ad ANDNA, genera una coppia di chiavi
  rsa, una pubblica (pub_key) ed una privata (priv_key). La dimensione della 
  pub_key sara' limitata, per questioni di spazio.
  La richiesta di un hostname fatta ad ANDNA verra' firmata con la chiave
  privata e nella richiesta stessa sara' allegata la chiave pubblica.
  In questo modo il nodo potra' far certificare l'originalita' delle sue future
  richieste.

  7.1.3  Count again

  Il numero massimo di hostnames che un nodo puo' registrare e' pari a 256,
  per prevenire la registrazione massiccia di hostnames formati da parole
  comuni da parte di spammer.
  L'unico problema in andna sarebbe quello di  contare. Il sistema e'
  totalmente distribuito e, quindi, non si puo' tenere il conto di quanti
  hostname ha registrato un nodo. Esiste pero' una soluzione: introdurre un
  nuovo elemento, gli andna_counter_nodes.
  Un counter_node e' un nodo che ha un ip uguale all'hash della public key del 
  nodo che registra gli hostname.
  Il counter_node si occupa di memorizzare il numero di hostname che
  ha memorizzato il register_node che gli corrisponde. Quindi, quando un
  hash_gnode riceve una richiesta di registrazione, prima di tutto contatta il
  relativo counter_node, che gli comunica quanti host_name sono gia' stati
  registrati dal register_node: se il nodo non ha sforato il proprio
  limite, allora il counter node incrementa il contatore e l'hash_gnode
  registra effettivamente l'hostname.
  L'attivazione di un counter_gnode avviene con la richiesta di controllo da
  parte dell'hash_gnode e viene mantenuta dalla successive richieste.
  Il meccanismo e' identico a quello dell'andna, e, pertanto, il register_node 
  si deve anche preoccupare di mantenere il suo counter_node attivo seguendo le
  stesse regole dell'ibernazione (vedi sotto).
  In pratica, se il counter_node non riceve piu' richieste di controllo da
  parte degli hash_gnode, si disattiva, e tutti gli hostname registrati non sono
  piu' validi (non si possono piu' aggiornare).
  
  7.1.4  Registration step by step
  
  Il nodo x,  che vuole registrare il suo hostname, trova il gnode piu' vicino
  all'hash_gnode (o l'hash_gnode stesso), contatta un nodo a caso (il nodo y)
  di quel gnode e gli manda la richiesta.
  La richiesta include una public key di una coppia di chiavi RSA appena
  generata (ad ogni registrazione corrisponde una nuova coppia di chiavi). Il
  pkt viene anche firmato con la priv_key.
  Il nodo y controlla di essere effettivamente nel gnode piu' vicino
  all'hash_node, in caso contrario rigetta la richiesta. Viene controllata
  anche la validita' della firma apposta nella richiesta.
  Il nodo y, contatta il counter_node e gli manda l'ip, l'hostname del
  register_node e la copia della richiesta. 
  Il counter verifica i dati e controlla che la firma apposta sulla richiesta
  sia valida, e da' l'ok.
  Il nodo y, dopo l'ok, accetta la richiesta, crea l'entry nel suo db
  annotando la data di registrazione, e manda in broadcast, all'interno del
  gnode, la richiesta.
  Gli altri nodi dell'hash_gnode che ricevono la richiesta controllano la sua
  validita' e la memorizzano l'entry nel loro db. 
  A questo punto il nodo x deve solo preoccuparsi di mandare la richiesta ai
  backup_gnode. Quando i nodi dei backup_gnode ricevono la richiesta,
  controllano di essere nel range dei gnode piu' vicini, e riapplicano la
  stessa procedura.
  
  7.1.5  Endless rest and rebirth

  Gli hash_gnode mantengono gli hostname in uno stato di ibernazione per circa
  3 giorni dal momento della loro registrazione od aggiornamento.
  Il tempo di decadimento e' volutamente molto alto per mantenere i domini 
  stabili. In questo modo, anche se qualcuno attacca un nodo per appropriarsi
  del suo dominio, dovra' aspettare 3 giorni.
  Quando il tempo di ibernazione si e' esaurito allora tutti gli hostname
  scaduti vengono cancellati e vengono sostituiti dagli altri hostname in
  coda.
  Un nodo deve mandare una richiesta di aggiornamento dei suoi hostname ogni 
  qualvolta il suo ip cambia e in ogni caso prima dello scadere del tempo di
  ibernazione, in questo modo il suo hostname non sara' cancellato.
  Il pacchetto della richiesta di aggiornamento ha un id che indica il numero
  di aggiornamenti gia' mandati. Il pacchetto viene anche firmato con la
  chiave privata del nodo, per garantire l'autenticita' della richiesta.
  Il pkt viene mandato ad un nodo qualsiasi dell'hash_gnode. Quest'ultimo nodo
  contattera' il counter_node, mandando anche una copia della richiesta, per
  aggiornare le sue entry e per verificare che sia ancora attivo e che l'entry
  relativa all'hostname da aggiornare sia presente. In caso contrario, la
  richiesta di aggiornamento viene rigettata.
  Se tutto va bene, il nodo forwarda la richiesta di aggiornamento all'interno
  dell'hash_gnode.
  Il register_node deve poi mandare la richiesta di aggiornamento anche ai
  backup_gnode e al counter_node.
  Se la richiesta di aggiornamento viene mandata troppo presto (nel primo
  giorno), verra' considerata invalida e sara' ignorata.
  

  7.1.6  Hash_gnodes mutation
  
  Se un generico rounded_gnode viene scavalcato da un nuovo gnode che e' piu'
  vicino all'hash_gnode deve lasciargli il posto, quindi avviene un
  trasferimento dal vecchio rounded_gnode al nuovo.
  La transizione, pero', avviene in maniera passiva: quando il register_node
  fara' l'aggiornamento dell'hostname, si rivolgera' direttamente al nuovo
  rounded_gnode. Gli hostname presenti nel vecchio rounded_gnode, non essendo
  piu' aggiornati, decaderanno.
  Nel frattempo, quando ancora l'hostname non e' stato aggiornato, tutti i
  nodi che vogliono risolverlo, troveranno il nuovo rounded_gnode come gnode
  piu' vicino all'hash_gnode, quindi manderanno le richieste al nuovo gnode.
  Il nuovo rounded_gnode, non avendo ancora il db, chiedera' a sua volta la
  risoluzione del nome host al rounded_gnode piu' vicino.
  
  7.1.7  Yaq: Yet another queue
  
  Ogni nodo ha la liberta' di scegliersi un qualsiasi nome host. Quando un nodo
  sceglie un hostname, prima controlla il gnode corrispondente per vedere se
  ne esiste gia' uno identico. Se l'hostname esiste, il nodo viene avvisato e
  sconsigliato dal proseguire. Proseguendo, il nodo manda una richiesta al
  gnode che conservera' l'hostname, la richiesta viene accettata, e
  viene aggiunta in coda, dove massimo possono esserci MAX_ANDNA_QUEUE (5)
  hostname. Nell'hash_gnode il nodo viene associato al nome host che ha
  richiesto e viene memorizzata anche la data di richiesta.
  Quando un nodo deve risolvere un hostname, consulta l'hash_gnode, e l'ip che
  e' associato a quell'hostname. Il nodo puo' anche scegliere di usare gli
  altri ip nella coda che sono associati allo stesso hostname.

  
  7.8	Hostname resolution

  Per risolvere un hostname il nodo X deve semplicemente trovare l'hash_gnode
  relativo all'hostname e mandare ad un nodo a caso di quel gnode la richiesta
  di risoluzione.
  
  7.8.1  Distributed cache for hostname resolution

  Per incrementare l'efficienza di risoluzione di hostname, si adotta una
  piccola strategia: un nodo, ogni volta che risolve un hostname, memorizza
  il risultato in una cache. Per ogni risoluzione successiva dello stesso
  hostname, il nodo avra' gia' il risultato nella sua cache. 
  Poiche' nei pacchetti di risoluzione degli hostname e' indicato il tempo
  dell'ultima volta in cui sono stati registrati o aggiornati, un entry nella
  cache scade esattamente quando l'hostname non e' piu' valido in ANDNA e deve
  essere aggiornato.
  La resolved_hnames cache e' accessibile a qualunque nodo.
  Un nodo X, sfruttando questa proprieta', se non ha l'hostname da risolvere
  nella sua cache, puo' decidere di chiedere ad un qualsiasi bnode Y scelto a
  caso del suo stesso gnode di risolvere per lui l'hostname desiderato.
  Il bnode Y, cerchera' nella sua resolved cache l'hostname e in caso di esito
  negativo, risolvera' l'hostname in modo standard facendo mandare la risposta
  al nodo X.
  Questo sistema previene l'overload degli hash_gnode che mantengono hostname
  molto famosi.
  
  
  7.8.2  noituloser emantsoh esreveR

  Se un nodo vuole conoscere tutti gli hostname associati as un ip, contatta
  direttamente il nodo che ha quell'ip.

  7.9  dns wrapper

  Un wrapper di richieste DNS, si occupera' di mandare al demone di ANDNA gli
  hostname da risolvere e di restituire gli ip associati ad essi.
  Grazie al wrapper sara' possibile usare ANDNA senza modificare alcun
  programma esistente: bastera' usare come server dns il proprio computer.
  

  8.   Heavy Load: flood your ass!

  Le rotte settate da Netsukuku sono create col supporto nexthop, che permette
  ad un nodo di raggiungere un altro nodo usando piu' rotte simultaneamente
  (multipath), garantendo uno smistamento equo del traffico dei pkts.
  Lo scudo anti-flood e' una conseguenza dell'avere delle rotte 
  multipath, ed essere collegati a piu' rnodes. Infatti, anche quando un
  nodo e'  bombardato da un flusso di dati continuo e sostenuto, riceve
  quel flusso diviso in differenti rotte e differenti link, e quindi puo'
  sempre comunicare con altri nodi.

  9.   Spoof the Wired: happy kiddies

  Se un nodo si aggancia a Netsukuku spoofando un ip, non concludera' nulla
  semplicemente perche' nessun nodo sapra' come raggiungerlo, avendo gia' la
  rotta esatta per raggiungere il nodo originale.
  In secondo luogo, gli rnode non permettono un aggancio di un ip che e' gia'
  presente nelle mappe.

  10.  /dev/accessibility
  
  Il mezzo ideale per connettere i nodi tra loro e', ovviamente, il wifi, ma
  qualunque tipo di link che connette due nodi serve allo scopo.
  I cellulari sono un ottimo dispositivo, su cui far girare Netsukuku.
  Alcuni dei nuovi modelli usano Linux come kernel. 
  
  11.  Internet compatibility

  Netsukuku non puo' diffondersi instantaneamente, ed e' impossibile pensare
  di poter migrare da Internet a Netsukuku immediatamente.
  Bisogna, quindi, che durante la sua iniziale diffusione, rimanga compatibile
  con il vecchio Internet e l'unico modo e' quello di limitare temporaneamente
  l'espandibilita' di Netsukuku.
  
  Un nodo che usa Netsukuku non puo' uscire su Internet perche', quando
  netsukuku_d viene avviato, come default gw viene settato lo stesso indirizzo ip
  assegnato all'interfaccia di rete, in questo modo le classi di ip non esistono
  piu', e qualsiasi nodo puo' prendersi qualsiasi ip random; inoltre, dato che
  gli ip vengono scelti in maniera random, possono accadere molte collisioni con
  gli attuali ip di Internet.
  
  Per mantenere la compabilita' con Internet, Netsukuku deve essere ristretto ad 
  una sotto classe di ip, in modo da non interferire con il default gw che esce 
  su Internet. Allora, per non interferire in nessun modo con Internet, usiamo
  la classe A degli indirizzi privati per l'ipv4, e la classe Site-Local per
  l'ipv6.
  
  Il passaggio dal Netsukuku ristretto al Netsukuku completo e' semplice: 
  nel momento stesso in cui un utente decide di abbandonare Internet, riavvia
  NetsukukuD senza l'opzione di restrizione.

  Ovviamente le altre classi private di ip non vengono toccate, per lasciare la
  possibilita' di creare una LAN con un solo gw/nodo netsukuku.
  
  12.  Implementation: let's code
  
  Il layer del protocollo Netsukuku non e' low-level, perche'  tutto quello 
  che deve fare in Netsukuku e' settare le rotte nella tabella di routing del
  kernel, percio' il demone NetsukukuD gira in userspace.
  Tutto il sistema viene quindi gestito dal demone che gira su ogni nodo. 
  NetsukukuD comunica con gli altri nodi attraverso l'udp e il tcp e setta le 
  rotte nella tabella del kernel.

  Tutto il codice e' scritto in C ed e' commentato, quindi non dovrebbe essere
  difficile seguire il flusso del programma, in ogni caso, prima di leggere un
  .c e' consigliato sbirciare il relativo .h .
  
  Netsukuku.c si occupa di lanciare i 4 thread-demone principali.
  Il primo ascolta sulla porta 269-udp con daemon.c/udp_daemon() e passa tutti
  i pacchetti ricevuti a pkts.c/pkt_exec(). 
  Il secondo thread e' identico al primo, con la differenza che ascolta sulla
  porta 270-udp e riceve solamente i pacchetti inviati dal radar.
  Il terzo thread ascolta sulla porta 269-tcp.
  In realta', tutti i pacchetti ricevuti dai demoni non vengono passati
  direttamente a pkts.c/pkt_exec(), ma prima, vengono filtrati da accept.c e da
  request.c che grazie ad una piccola tabella prevengono eventuali attacchi di
  flood. (accept.c e' lo stesso codice che e' stato usato per patchare la
  vulnerabita' user-level-denial-of-service di OpenSSH.)
  Il quarto ed ultimo thread e' quello che si occupa di lanciare
  hook.c/netsukuku_hook(), il codice che gestisce l'hook alla rete.
  
  Hook.c avviera' per la prima volta il primo radar scan con
  radar.c/radar_scan(). Tutti i pacchetti ricevuti, relativi al radar, sono
  gestiti da radar.c/radard() e da radar.c/radar_recv_reply().
  Dopo l'aggancio alla rete, il quarto thread si trasformera' nel radar_scan
  thread, infatti non fara' altro che eseguire in eterno la funzione
  radar.c/radar_daemon() che lancia un radar_scan() ogni MAX_RADAR_WAIT
  secondi. Quando il radar_update_map() si accorge di un cambiamento nei suoi
  rnode spedisce un nuovo qspn_close con qspn.c/qspn_send().
  Tutto il codice relativo al qspn e ai tracer_pkt si trova in qspn.c e in
  tracer.c.
  
  I socket, sockaddr, le connect, i recv(), i send, etc... sono tutte in
  inet.c, e vengono utilizzate da pkts.c.
  pkts.c si occupa di ricevere le richieste con pkt_exec() e mandarne con
  send_rq(), un front-end utilizzato per impacchettare e spedire la grande
  maggioranza di richieste.
  ipv6-gmp.c usa la libreria GMP (GNU multiple precision arithmetic library)
  per poter manipolare i 16 byte di un ipv6 come se fossero un unico grande
  numero, questo e' essenziale per alcune formule che agiscono direttamente
  sull'ip per poter ricavare molte informazioni, infatti, in Netsukuku un ip
  e' un numero a tutti gli effetti.

  Il codice che si interfaccia al kernel per settare le rotte nella route
  table e per configurare un'interfaccia di rete si trova in:
  krnl_route.c, if.c, ll_map.c, krnl_rule.c, libnetlink.c.
  Route.c fa' da intermediario tra il codice che gestisce il protocollo di
  netsukuku e tra le funzioni che comunicano con il kernel.

  Per quanto riguarda le mappe tutto si basa su map.c, il sorgente che
  si occupa di prendersi cura della mappa interna. Tutta le altre mappe si
  appogiano su map.c, e sono:
  bmap.c per la border node map, gmap.c per la mappa esterna.
  
  Per compilare il codice di Netsukuku non e' necessario usare autoconf,
  automake e famiglia, ma basta usare il comodo scons (http://www.scons.org).
  Il file SConstruct e' appunto il "Makefile" di scons.

  L'ultima versione del codice e' sempre disponibile sul cvs degli
  hinezumilabs: 

  cvs -d :pserver:anoncvs@hinezumilabs.org:/home/cvsroot login
  
  oppure date un'occhiata da qui:
  
  http://hinezumilabs.org/cgi-bin/viewcvs.cgi/netsukuku/
  

  13.  What to do

  Prima di incominciare a diffondere Netsukuku e' necessario compiere ancora
  qualche passo essenziale:
  - Scrivere il codice dell'ANDNA. Una rete priva di un sistema di gestione di
    dominii e' praticamente inusabile.
  - Testare su larga scala Netsukuku
  - Completare i src/TODO.
  - Completare i TODO che si trovano in questo documento ;)
  - Varie ed eventuali.

  Chi vuole imbarcarsi faccia un fischio.
  

  14.  The smoked ones who made Netsukuku

  Andrea Lo Pumo   aka   AlpT				<alpt@freaknet.org>
 
  
  Special thanks to:
  
  Valvoline the non-existent entity for the implementation advices,
  Newmark, the hibernated guy who helped in some ANDNA problems,
  Crash aka "il nipponico bionico" who takes BSD, breathes the 2.4Ghz and
        worship the great Disagio,
  Tomak aka "il magnanimo" who watches everything with his crypto eyes and
        talks in the unrandomish slang,
  Asbesto aka "l'iniziatore" who lives to destroy the old to build the new,
  Nirvana who exists everywhere to bring peace in your data,
  Ram aka "il maledetto poeta" who builds streams of null filled with the
	infinite,
  Quest who taught me to look in the Code,
  Martin, the immortal coder and our beloved father,
  Elibus, the eternal packet present in your lines,
  Pallotron, the biatomic super AI used to build stream of consciousness,
  Entropika, the Great Mother of Enea,
  Uscinziatu, the attentive,
  Shezzan, the holy bard of the two worlds,
  Katolaz,
  Gamel,
  ...
  the list goes on...
  V C G R A N Q E M P N E T S U K

  and finally thanks to all the
  
  Freaknet  Medialab      <www.freaknet.org>
  
  whose we are all part, and the poetry

  Poetry Hacklab          <poetry.freaknet.org - poetry.homelinux.org>
  
  
--
This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike License. 
To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/2.0/ or send a
letter to Creative Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
